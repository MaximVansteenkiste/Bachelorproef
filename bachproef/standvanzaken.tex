\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

A modern website is created with three main technologies: HTML for content, CSS for styling, and JavaScript to make the page interactive. Those three can all be linked, put on a server somewhere and the end-user can load a working website. Even though the large web platforms of today, like Facebook and Youtube, are all based on these technologies, a lot more ingredients are needed to make them work.

If we were to create a static, basic site, the three main technologies of the web are all you need. But it’s a whole different story for a developer that wants to create a more complex site, a reactive site, a site that uses open-source packages or just wants to make their own job a little bit easier. There are thousands of libraries, packages and frameworks that enable web development on a whole new level and easier than ever before. However this does pose a new problem. 

If we were to create a web application with a single JavaScript file and no dependencies i.e no other files that are linked to that JavaScript file, link it to our index.html and throw in some CSS, our site would work fine. But what if we introduce a second JavaScript file and reference it in our other file. What if we want to install and use an open-source package downloaded from a package-manager like NPM? What if we want to use SASS to extend CSS? This all wouldn’t work. The browser just isn’t able to figure out how to stich all the different pieces together.
We need something that will bundle all the different JavaScript files and dependencies, something that understands and correctly loads the SASS files or any other file for that matter. We need a module bundler. In essence, they take all the different source files in a project and put them into a single output file that the browser understands. 

\section{Before bundlers}

The web has been around for some time. Developers have been able to run JavaScript on their websites since … . But the first module bundlers only came around after 2014. To understand why module bundlers exist, we should first know how web applications were built before them and what problem they solved.

\section{Script tags}
JavaScript can be linked to, or written directly in, the HTML file of our site using script-tags. Knowing this, we could use a different one for each use case. Let’s say we have a file with all the code for authenticating a user and another one for general events (button clicks, ...). This is fine when we only have two files that aren’t that big, but introduces network bottlenecks when scaled to a larger application. The same is true if we were to put all our code in one large JS file and link it to the HTML. The global scope also et’s polluted with our own functions. As some, or all, the functions are available on the global scope, this could introduce security risks and name collisions. 

\section{Immediately invoked function expressions}
An Immediately invoked function expression or IIFE is a function that runs as soon as it’s defined. This way, our functions aren’t available on the global scope. The use of IFFEs led to so-called task runners: they concatenate all your project files together. The big drawback of task runners is that when one file is changed, the whole project has to be rebuilt. You are also required to manually define all the dependencies up front. It makes it easier to reuse functions and whole scripts but does nothing for the build output. You can still end up with a very large JS file that the user has to download. 

\section{CommonJS}
Before 2009, JavaScript ran only in a browser. Node.js introduced a JavaScript runtime that could run on computers and servers. This introduced a set of new challenges. As JavaScript wasn’t run in the browser and therefore no HTML script-tags were around, how could those applications load new chunks of code? 

CommonJS introduced the require function in JavaScript. With it, everything that an external module exports, can be imported. Reusable code can now be imported from any other JS file in a project or using an NPM-package. It makes implementing dependency management easy to understand.

All this came with a big catch: It worked, and still works, great for Node.js applications but browsers don’t support it. As commonJS doesn’t actually bundle the code, browsers can’t make sense of the different modules that are imported. Something has to do it for them. 

\section{ECMAScript Modules}
CommonJS wasn’t an official feature of JavaScript. They did introduce ECMAScript Modules or ESM, which accomplishes the same goal of CommonJS, but with a different syntax. This does also mean that browser support isn’t complete and no bundler is present. 
