\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.


\section{Before bundlers}

The web has been around for some time. Developers have been able to run JavaScript on their websites since … . But the first module bundlers only came around after 2014. To understand why module bundlers exist, we should first know how web applications were built before them and what problem they solved.

\section{Script tags}
JavaScript can be linked to, or written directly in, the HTML file of our site using script-tags. Knowing this, we could use a different one for each use case. Let’s say we have a file with all the code for authenticating a user and another one for general events (button clicks, ...). This is fine when we only have two files that aren’t that big, but introduces network bottlenecks when scaled to a larger application. The same is true if we were to put all our code in one large JS file and link it to the HTML. The global scope also et’s polluted with our own functions. As some, or all, the functions are available on the global scope, this could introduce security risks and name collisions. 

\section{Immediately invoked function expressions}
An Immediately invoked function expression or IIFE is a function that runs as soon as it’s defined. This way, our functions aren’t available on the global scope. The use of IFFEs led to so-called task runners: they concatenate all your project files together. The big drawback of task runners is that when one file is changed, the whole project has to be rebuilt. You are also required to manually define all the dependencies up front. It makes it easier to reuse functions and whole scripts but does nothing for the build output. You can still end up with a very large JS file that the user has to download. 

\section{CommonJS}
Before 2009, JavaScript ran only in a browser. Node.js introduced a JavaScript runtime that could run on computers and servers. This introduced a set of new challenges. As JavaScript wasn’t run in the browser and therefore no HTML script-tags were around, how could those applications load new chunks of code? 

CommonJS introduced the require function in JavaScript. With it, everything that an external module exports, can be imported. Reusable code can now be imported from any other JS file in a project or using an NPM-package. It makes implementing dependency management easy to understand.

All this came with a big catch: It worked, and still works, great for Node.js applications but browsers don’t support it. As commonJS doesn’t actually bundle the code, browsers can’t make sense of the different modules that are imported. Something has to do it for them. 

\section{ECMAScript Modules}
CommonJS wasn’t an official feature of JavaScript. They did introduce ECMAScript Modules or ESM, which accomplishes the same goal of CommonJS, but with a different syntax. This does also mean that browser support isn’t complete and no bundler is present. 
